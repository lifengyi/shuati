

数据源：
数据存储： 数组？
         队列？
         二叉树？(二叉树的表达方式有：树的方式，也有数组的方式，数组代表了完全二叉树)


数据序列：   有序无序
数据分布：   有无重复数据，integer:0+-, non-negative integer: 0+
数据源属性：  是否可以修改，而不是read-only

<-- 出错点：求最大值，默认数值为0，则当极限情况只有一个元素且为负的时候，将会出错

<-- max path sum, 当有且仅有一个节点，且为负数的时候，输出应该为该负数
    如果初始化sum值为0， 则在比较病存储sum时会出错，因为比较之后发现新的sum不如
    已经（默认）设置好的sum大，所以不会存储该新的sum数据。



处理要求：
空间复杂度， 时间复杂度


结果集：
是否保持原有的数据序列:
是： 暂不考虑sort，以及额外的存储空间


输入的完整性检测
输出在出错情况下，如何返回？ 异常？空集？



！！！！！！！！！！！！！！！！！  解题注意点:
0. 设计case

1. 思考总体解题思路

2. 将总体解题思路用代码来进行实现，同时注意以下细节：

    * 1个开头：参数完整性检测，极限情况的检测

    * 1个过程：处理逻辑中处理 0 中的细节

    * 2个结尾: a. 注意不要忘记return
              b. 注意return的东西需要符合要求
                 （即对题目的理解需要正确，多问问题以了解具体需要实现的结果集）






************************************************************************

Two Sum:
在给定资源中做匹配类型题，实现O(1)的时间复杂度， 故引用额外存储空间hashMap实现
以期待匹配的资源value作为key，实现O(1)内的搜索匹配。

根据数据源的不同情况，选择不同的时间复杂度，空间复杂度
no duplicated data =>  use set/map              => O(n)
duplicated data    =>  cannot use set/map

ordered ?          =>  iterate the list         => O(n) ?
no ordered         =>  Basic.sort first               => O(nlogN)
                   =>  iterate the list         => O(n^2)

变种1： 增加K
对于3Sum问题，有重复数据，且无序数组，要求输出有序元组，则采用优先排序  <<< 【有序的结果集=>排序先】
然后遍历数组O(n)，对于下的数组做双指针遍历O(n)故3Sum的时间复杂度为O(n^2)
推广至N个数据求KSum => O(N^(k-1)) , N to the power of K-1

变种2： 修改满足的条件
K Sum closest问题同理于K Sum, 输出的条件不再是等于目标值，而是与目标值的差值最小
即需要和当前保存的差值做比较，大则不作处理，等则加入当前输出序列，小则替换当前输出序列
故该复杂度和K Sum同样

************************************************************************


RDN

tips1: 对于冗余参数为K做去重，犯错误当发现有重复项时，重复项计数器为count
      判断计数器和K if(count < k) ， 如果count从0开始计数，则错，
      因为当第一次检查到有重复项时，此刻是第1次遇到重复项，但是重复数据已经有2个了

      需要注意去重时，重复计数器的问题
      重复计数器n，代表了第n次遇到，同时也代表了已经出现了n+1个重复项目
      如果n从0开始计数，则重复项检查应该是 if(n < k - 1)
      如果n从1开始计数，则重复项检查应该是 if(n < k)

tips2: while做索引条件检测， while(index 满足 条件)，index增值操作在循环里做


************************************************************************

Container With Most water

两条件a与b相结合得出最优解，
选一条件a采用最优方案，另一条件b当前状态，得出初始解决方案，
对a条件进行单向自然降低，搜索条件b的更优解，得出结果与初始解决方案比较

该题最优结果： Max( (x2-x1) * Min(y1, y2) )
初始状态，取x2-x1的最大，得出初始状态的容积；
针对较小纵坐标，减少其横坐标，搜索纵坐标的较大值 =》 降低a条件，搜索更优



************************************************************************
Trapping water
单向从左至右遍历时，最开始考虑的是找到一个独立容器，知道比当前left bar 大或者等于的right bar
返回两边bar的索引，单独创建函数计算容量，为什么考虑不到，在检索bar的时候就已经计算容量呢？
<<< 之所以不在一边检索一边计算的原因是对于之后的数据中不知道是否有符合标准的right bar
故没有计算,

同时还要保存仅次当前left bar的最大right bar，也是出于上述同样的原因，因为不知道后续
数据中是否有符合标准（大约等于当前left bar的right bar）

那么为什么不想办法做到预先能知道是否有这么一个bar的存在？？？这样不仅可以简化代码，也可以检索的
同时从而计算

方法1. 遍历数组找到最高的那个bar，那么所有小于的bar在向前搜索大于等于的bar时，可以计算相应
的雨水容量，同时设置双指针，从两端想最高的bar进行遍历计算

方法2. 不需要第一次遍历整个数组，左右两边指针移动较小的那个bar，因为小bar的那部分容量必然
可以计算在内，移动的同时计算雨水容量，每次遇到比当前移动bar高的bar时，检查是否需要交换移动bar



************************************************************************

Tips:

1. 命名要规范，区别变量是一个数组的下标index，还是一个index所在的值防止编写代码的时候混淆。
2. 遍历的时候在不熟悉情况下，不要随便在遍历的索引上同时进行比较值操作和移动操作，
   即：使用index做数据的比较和操作，同时也对index进行自增和自减操作。


************************************************************************

分治法与动态规划的相同点：
分治法与动态规划，二者要求原问题具有最有子结构，都是将问题分而治之分解成若干个规模较小的子问题；

不同点：
动态规划是将原问题分解为多个子问题，前一子问题的解，为后一子问题的求解提供了有用的信息。
在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解
通过计算出子问题的结果构造一个最优解。动态规划通过迭代法自底向上求解，动态规划将分解后的子问题理解
为相互间有联系，有重叠的部分；（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
算法的应用：装配线，矩阵乘法，最长公共子序列，构造最优的二叉树

分治法是将原问题分解为多个子问题，利用递归对各个子问题独立求解，最后利用各子问题的解进行合并形成原问题的解。
分治法将分解后的子问题看成是相互独立的。
算法的应用：二分搜索，大整数乘法，合并排序，快速排序


贪心算法：依赖于当前已经做出的所有选择，采用自顶向下(每一步根据策略得到当前一个最优解，
保证每一步都是选择当前最优的)的解决方法。
贪心算法的应用：最小生成树，最短路径，数据压缩--哈夫曼编码，
Candy
Trapping water




******************************************************************************************************

Array相关题目：

解题思路：
1. 数组元素的值作为数组的下标再次进行索引找到对应的元素，然后做某种相关操作， 基本上属于数组内部元素互相之间移动替换。
   此类解题思路基本上是在 "数组的索引"和"索引对应的值"上面做文章
   参看： 189 Rotate Array
         41  First Missing Positive

2. 数组遍历1次，每访问一个节点就做一个当前的最优解，DP贪心算法。遍历完毕得到最优解。也可理解为分而治之。
   难点在于如何建模出所谓的当前最优解：
   此类提醒基本上是DP算法
   参看： 53   Maximum Subarray
         152  Maximum Product Subarray
         198  House Robber

解题技巧：
1. 很多简单的数组问题有时候可以多考虑排序后再找寻解决方案

2. 以上若干方法在使用的过程中，经常遇到一个最终解需要处理2种情况，例如可能出现A或B情况，A/B都可能出最优解，
   那么就是A/B情况下分别求解，然后比较两者的答案 213 House Robber II
   或者将两个答案结合起来就是最终的解;； 238. Product of Array Except Self

出错点：
1. 针对各种不同的边缘case逻辑，涉及不同的数组指针操作
   方法a. 看到题目non-integer，写下0和+， 当题目看到integer，写下0，-和+，提醒自己注意不同情况
   方法b. 是否可以移动数据

******************************************************************************************************

对于上述集体思路中的 DP算法 的展开叙述，同样适用于解其他类型的题目  *******
a. 遍历节点，DP方法求最优解，每一次访问节点，将当前节点的最优解和全局最优解做比较，保存更好的解
   方法适用于结果双向性，即后续节点的访问可能不能形成最优解
   例如：  53   Maximum Subarray
          152  Maximum Product Subarray
          124. Binary Tree Maximum Path Sum

b. 遍历节点，DP方法求最优解，每一次访问节点，得出当前节点的最优解返回供后续使用，最后一个节点的最优解即最优解
   方法适用于结果单向性的，例如节点元素都为integer，即0或者正整数，求最大sum
   例如： 198 House Robber
         213 House Robber II
         337 House Robber III


另一个方法需要注意：
目前遇到的题目中经常遇到如下情形： 最优解可能在A情形得出一个最优解，但是B情形下也有可能得出最优解，但是A和B情况均有可能出现，
采取的错误方法：在一次遍历中同时处理A和B情形，虽然有时候也得出最优解，但是过程很繁琐，代码很混乱，容易出错。

策略上使用分治，分治后的每个问题的具体求解，使用动态规划：
即将A和B分别进行处理，假定A出现时求最优解A'， 假定B出现时出现最优解B'， 最后总和考虑A'和B'的情况



******************************************************************************************************

Utility function:
1, 交换2个数字，但不引入临时变量，异或
   原理同一个数字异或两次消失归零，
   应用: 求解数字只出现基数次的题型

2，求最大公约数， greatest common divisor

3，求素数， prime

4. n & -n  => 得到最后一个1的位置
    应用: 数组中2个数字出现1此，其他都出现2次；

5. n & n - 1 => 消除最后一个数字
    应用: 判断一个数是不是2的幂次；判断一个数中1的个数

6. n ^ n 归零
     应用：寻找出现奇数次的数字



******************************************************************************************************
******************************************************************************************************
******************************************************************************************************
******************************************************************************************************





************************************************************************
*************************  解题思路 之 题型篇 *****************************
************************************************************************


Array
解题思路：
        1. 数组元素的值作为数组的下标再次进行索引找到对应的元素，然后做某种相关操作，
           基本上属于数组内部元素互相之间移动替换。
           此类解题思路基本上是在 "数组的索引"和"索引对应的值"上面做文章
           参看： 189 Rotate Array
                 41  First Missing Positive


        2. 数组遍历1次，每访问一个节点就做一个当前的最优解，DP贪心算法。遍历完毕得到最优解。也可理解为分而治之。
           难点在于如何建模出所谓的当前最优解：
           此类提醒基本上是DP算法
           参看： 53   Maximum Subarray
                 152  Maximum Product Subarray
                 198  House Robber

           （见后续通用解题思路中的 DC+DP）
解题技巧：
        1. 很多简单的数组问题有时候可以多考虑排序后再找寻解决方案
        2. 以上若干方法在使用的过程中，经常遇到一个最终解需要处理2种情况，例如可能出现A或B情况，A/B都可能出最优解，
           采用分治：
           那么就是A/B情况下分别求解，然后比较两者的答案 213 House Robber II
           或者将两个答案结合起来就是最终的解;； 238. Product of Array Except Self

           （见后续通用解题思路中的 DC+DP ）

出错点：
        针对各种不同的边缘case逻辑，涉及不同的数组指针操作
             方法a. 看到题目non-integer，写下0和+， 当题目看到integer，写下0，-和+，提醒自己注意不同情况
             方法b. 是否可以移动数据
        链表型考题考点：各种简单算法 + 边缘case的坑点
            例如： 	2.    Add Two Numbers
                    19.   Remove Nth Node From End of List
                    21.   Merge Two Sorted Lists

******************************************************************************************************


链表型解题技巧：
1.  设置dummyNode作为头结点，可以简化代码
2.  one pass时的解题技巧:快慢指针 （见后续通用解题思路中的指针类解题）


******************************************************************************************************


字符串型解题技巧：
1.  对于字符串中的字符设置对应的ascii表，或者hash表


******************************************************************************************************


Sliding Window

减一个元素，加一个元素

辅助以
Heap(PriorityQueue, TreeSet)       Sliding Window Median
单调stack，
单调Deque能解决很多问题                Sliding Window Maximum


************************************************************************
*************************  解题思路 之 算法篇 *****************************
************************************************************************

求集合中的最大、最小值时，就要想到 Heap

Priority Queue:
offer:  O(logN)
poll :  O(logN)  最小/最大
peek :  O(1)
remove : O(n)

删除节点的复杂度为n主要是因为需要遍历数组中所有元素，并将其和数组尾部的数据进行交换，然后尾部
数据删除，而原有位置上的数据需要heapify操作： n + logN => O(n)

如果需要提高删除节点的速度，怎么办？可以考虑使用 TreeSet/TreeMap, 具有hash + heap的功能
本质上它是一个平衡二叉树，可以取得最大值，最小值，插入、删除数据

TreeMap/TreeSet
first :   O(logN)  最小
poolFirst:

last  :   O(logN)  最大
poolLast:

remove :  O(logN)
insert :  O(logN)


需要注意的是： treeSet不能放入重复元素，会被过滤掉，如何解决，引入一个新的class，放入id和value
如果value相同，则返回id的相减。

TreeSet虽然优化了删除节点操作，但是也增加了其他操作的时间复杂度，如何在保留原有heap其他
操作的时间复杂度情况下，再优化删除节点操作？ 实现自己的Heap类，同时对heap中数组中的每个
元素在HashMap中缓存， key为值，value为数组索引下标, 从而实现 HashHeap




************************************************************************************
************************************************************************************
************************************************************************************

线性数据结构 ， 可以O(n)的时间复杂度实现

Queue，Stack，Deque

stack：  普通stack， 存储有用信息，从而实现链表翻转等

         单调stack， 找每个元素左边或者右边第一个比它自身小/大的元素时用单调栈来维护

deque：  单调deque，类似单调stack，但是可以实现从当前维护的表中移走数据，使用与滑动窗口
         类型的题目




************************************************************************************
************************************************************************************
************************************************************************************
不同类型题的通用解题思路：


DP
a. 遍历节点，DP方法求最优解，每一次访问节点，将当前节点的最优解和全局最优解做比较，保存更好的解
   方法适用于结果双向性，即后续节点的访问可能不能形成最优解
   例如：  53   Maximum Subarray
          152  Maximum Product Subarray
          124. Binary Tree Maximum Path Sum

b. 遍历节点，DP方法求最优解，每一次访问节点，得出当前节点的最优解返回供后续使用，最后一个节点的最优解即最优解
   方法适用于结果单向性的，例如节点元素都为integer，即0或者正整数，求最大sum
   例如： 198 House Robber
         213 House Robber II
         337 House Robber III


DP模式：
1. fn <==>  fn-1 + fn-2
    例如： Climbing stairs + Decoding ways

2. fn <==>  fn-1-con1 + fn-1-con2
    例如： House Robber



DP相关总结：
1.
将动态规划的常见类型分为如下几种：
矩阵型
序列型
双序列型
划分型
区间型
背包型
状态压缩型
树型

面试中经常出现的是矩阵型，序列型和双序列型。划分型，区间型和背包型偶尔出现。

状态压缩和树型基本不会出现（一般在算法竞赛中才会出现）。每种类型都有着自己的题目特点和状态的表示方法。

以矩阵型动态规划为例，一般题目会给你一个矩阵，告诉你有一个小人在上面走动，每次只能向右和向下走，

然后问你比如有多少种方案从左上走到右下(不同的路径link) 。这种类型状态表示的特点一般是使用坐标作为状态，

如f[i][j]表示走到(i,j)这个位置的时候，一共有多少种方案。状态的转移则是考虑是从哪儿走到(i,j)这个坐标的。

而序列型的动态规划，一般是告诉你一个序列；双序列的动态规划一般是告诉你两个字符串或者两个序列。

2.
可以使用动态规划的问题一般都有一些特点可以遵循。如题目的问法一般是三种方式：
求最大值/最小值
求可不可行
求方案总数
如果你碰到一个问题，是问你这三个问题之一的，那么有90%的概率是使用动态规划来求解。
要重点说明的是，如果一个问题让你求出“所有的”方案和结果，则肯定不是使用动态规划。

3.
判断是否是动态规划的问题，如果是，则尝试将其按照以上1中描述进行分类，找到对应的类别和相似的问题。接着从下面的4个要素去逐步剖析解决这道题：
状态是什么
状态转移方程是什么
状态的初始值是什么
问题要求的最后答案是什么
每个步骤分析完成之后，就基本上解决了整道动态规划的问题。


************************************************************************
DC + DP
213. House Robber II

目前遇到的题目中经常遇到如下情形： 最优解可能在A情形得出一个最优解，但是B情形下也有可能得出最优解，但是A和B情况均有可能出现，
采取的错误方法：在一次遍历中同时处理A和B情形，虽然有时候也得出最优解，但是过程很繁琐，代码很混乱，容易出错。

策略上使用分治，分治后的每个问题的具体求解，使用动态规划：
即将A和B分别进行处理，假定A出现时求最优解A'， 假定B出现时出现最优解B'， 最后总和考虑A'和B'的情况


************************************************************************

指针解题类型：

双指针 ----> 前向 ------> 窗口
      |         |
      |         |-----> 快慢
      |
      |
      |---> 相向



************************************************************************



通用错误点：
1. 2个int相加/相减，需要防止溢出，代码需要特殊处理。





