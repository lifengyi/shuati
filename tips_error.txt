102. Binary Tree Level Order Traversal
    a.  LinkedList::push vs LinedList::add

    b.  LinkedList::add(obj) 增加一个reference，加完后对obj做操作，会反应到list中
        obj有可能也是一个collection，如果改变元素，或者清空元素，同样反应到list中

    c.  LinkedList.size()获得当前list/fifo/stack的长度


124. Binary Tree Maximum Path Sum
1. 数据分布： 有无重复数据，有无正负数据
    <-- 出错点：求最大值，默认数值为0，则当极限情况只有一个元素且为负的时候，将会出错
    <-- max path sum, 当有且仅有一个节点，且为负数的时候，输出应该为该负数
        如果初始化sum值为0， 则在比较病存储sum时会出错，因为比较之后发现新的sum不如
        已经（默认）设置好的sum大，所以不会存储该新的sum数据。
2. 由于1中描述的情况，那么sum的默认值不应该再为0，而是采用 Integer.MIN_VALUE
   我自己采用的是比较老土的方法，设置一个flag来判断是否是第一次得到真实的sum值
3. 方法2极大地简化了代码的复杂度



236. Lowest Common Ancestor of a Binary Tree
v1 代码中的比较 root == p / root == q, 前提假设是p和q都是现有tree中的节点，
当此假设成立，则代码运行成功，如果这两个节点都是new出来的节点作为参数传入，则测试失败。
leetcode中的样例也是按照此假设进行测试的。
基于上述前提，假如把比较代码换成 root.val == p.val，则将会出错。但是从另一面来说，
假如该binary tree中含有多个具有相同val的节点，采用比价节点值的方法，似乎很难适合这个题目，
所以采用判断TreeNode是否指向同一个对象，也比较符合逻辑。

当tree中没有重复值，且对于比较的节点不确定是否在tree中，用v2版本比较好，
v2专注于：不存在重复值的tree中，通过比较2个节点值，寻找公共祖先，2个节点都有可能不在tree中；
v1专注于：存在多个相同值的节点在于tree，通过比较2个节点地址，寻找公共祖先，2个节点必须都在tree中；


延伸：
1. 朴素算法，遍历tree，分别找到2个节点，保存从root到节点的路径到数组，比较数组中的前缀，
   直到找到不同节点开始，上一个节点即为LCA

2. 当节点有指向父节点的指针，可以通过节点逆向推到root，记录路径，再比较路径的前缀，同上。
   改进之一： 可以在找到另一个节点时，结束算法
   （2比1节省了不必要的节点遍历）

3. 当节点有指向父节点指针，每个节点也存有当前的depth，可采用如下算法：
   LCA(u, v): depth(u) < depth(v)   => LCA(u, parent(v));
              depth(u) >= depth(v)  => LCA(parent(u), v);
   递归指导u，v相等
   （3比1节省了对公共路径的遍历）


延伸1：推广到网络拓扑图中，两个底层客户端需要通过最近公共节点服务器进行同步时，
   a. 可以用3方法每次计算寻找公共节点
   b. 可以将所有节点两两之间的公共节点缓存起来，额外的空间复杂度O(n^2)


延伸2：结合并查集的概念，算法的复杂度取决于树的高度，如果是一个多叉树，做weighted union
      得到一个相对平和的多叉树。

      Weighted Quick-Union With Path Compression
      a. Weighted Quick-Union, 在合并结合树的时候，小树的根节点的父节点指向大树的根节点
      b. 做find操作的时候，讲节点的父节点指向爷爷节点


297. Serialize and Deserialize Binary Tree
String 和 Integer 相关的操作函数使用不熟练，例如
    Int => String  : String.valueOf(int n)
    String => Int  : Int.valueOf(String s)
    String.split();
    StringBuilder 相关函数

当初始想法曾经遍历做serize和deserize遇到问题，解决之后，很好。
但是，为什么没想到用其他顺序遍历，例如中序遍历？ 不仅能节省很多无谓的空间浪费，代码也更简洁。
无论哪种遍历，线性化和反线性化时的思想都是一样的。



297. Serialize and Deserialize Binary Tree

对于字符串，数字两个类的使用，以及他们之间的互相转换，欠缺熟练度，
Integer.valueOf()
String.valueOf()
String.split()
StringBuilder 类的使用


树的前序遍历输出，NULL节点单独标记为"null"， 换个角度来说，讲树作为一个满二叉树来记录
所有节点在放入fifo之后，可以递归还原树的结构



98. Validate Binary Search Tree

老问题：当出现复杂的if组合条件时，需要冷静的分析，宁愿使用俗套不好看的，切忌为了贪图代码简洁而使用一种自己没有把握的条件组合

一定要冷静的分析各种if条件的组合！！！！！



1. Two Sum

简单的排序问题，出错地方：！！！！！
    1. 要求返回的是满足条件的数字的下标索引，而我返回的是满足条件的数字
    2. 由于在1中犯下的错误，导致采用了排序的方法，导致索引全乱，显然是
       没有看清题意导致答题的失败！！！！

    3. 采用HashMap方案时，对HashMap的方法不够熟练
       HashMap::containsKey()
       HashMap::put()
       等等
    4. 采用HashMap方案时，犯下的大错误，当以值作为key进行缓存
       遍历当前数组，根据target -  array[i] 得出的值得在缓存中寻找时
       需要注意： 当找到结果时，需要判断找到的结果是不是当前正在遍历的节点
       例如： [3， 2，4] 寻找6时，遍历第一个节点时，在缓存中将会找到自己本身
       而这个答案是错的，应该过滤掉的！！！！！

不要因为题目的简单而犯下低级错误！！！！
首先要读懂题目的意思！！！


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  TBD <<<<<<<<<<<<<<<<<<<<
4. Median of Two Sorted Arrays

暴露出的问题:
    a. 对于数字double，int的转换问题，以及对于奇偶数的判断问题，显然对java的基本使用很差
    b. 方法1，将两个数组的长度相加，居然写出了第一个数组直接两次相加，暴露出写代码的粗心以及缺少
       基本的写时复查操作！！！！！！！！！
    c. 方法2，两个数组还是会写错，在操作nums2数组时，还是会写错成nums1，如何杜绝类似这种手误：
       1），写的时候务必复查
       2），写完之后做必要的模式匹配检查，杜绝这种手误 ！！！！
           希望能应用到日后刷题过程中！！！不要再出现这种错误！！！！！

    d. 数学知识的缺乏， 2 to the power of K >= n ( 2^k >= n) ？？？？？？？？？？？？？？？？？？？

    e. 当数据为排序好的时，需要考虑到二分思维 =》 logN的复杂度

    f. 一个int数字除以2.0，结果将直接被转换为double

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  TBD <<<<<<<<<<<<<<<<<<<<




15. 3Sum

1. return statement 总是忘记 ！！！
2. return的东西不是期望出来的东西，期望返回相对应的数字，而我返回的是数字的下标索引
3. 主循环i的每一次元素访问，考虑到可能存在重复数字，应该把与之前元素值相同的元素直接跳过
4. 当一次主循环中知道一组符合要求的集合后，应该继续再该序列找，而不是退出 【白痴错误】
5. 4之后继续犯的错误： 继续向前找的时候，序号和3一样，跳过相同的元素





33. Search in Rotated Sorted Array

1. 初始的实现代码在确定往左往右选取时间，采用了4个if判断，需要精简：
   a. 首先可以把命中的那个判断挪出去
   b. 剩下的可以根据target为主体，3个分支修改为2个
2. 以target为主题，判断往左右选取时，需要注意在和首节点和尾节点比较时，
   需要闭区间，因为他们可能就是我们要找的节点。
   这个是常规的二分查找中不需要考虑的部分，常规二分查找只需要考虑一个比较关系
   中值与target的大小，然后直接选取左右区间




34. Search for a Range    ！！！！！！！！！！！！！！！！！！

可以作为一个经典检查样板
1. 需要对参数sanity check
2. 不可以遗忘最后return，同时对return的东西需要明确是否符合题目的要求

本题中，返回target开始和结束的坐标，那么问题就是：否允许开始和最后的坐标是同一样的值，
即表示是否可允许目标值仅出现一次。
由于我的初步任务是不允许仅出现一次，所以逻辑中出现了如下的错误：
   a. sanitiy check中判断如果数组长度为1， 则返回出错的返回值
   b. 当找到target的开始和结束坐标后，判断坐标不唯一才能正确输出，
      否则就出错输出。
   a和b都是基于目标仅出现1次而做的逻辑，所以当然错了


<<<<<< !!!
33/34 两道题目典型的都是二分查找的问题，发现在这类问题中，头尾两个节点都要被依据index来访问，
并拿出来做各种比较，所以基本上无论是循环体，还是函数封装，都是以全闭合区间来操作，而不是左闭合区间

所以只有当顺序过滤序列，并一次访问序列中元素的场合，考虑使用左闭合区间
对于二分这种头尾节点都要被同时拿出来使用并比较的，最好使用全闭和区间






41. First Missing Positive

最主要的地方：该题引入了一个新的概念，在当前数组中，对数组进行本地的挪移，将数组中的相关节点放到应该的位置

题目的思路就是： 按照数组的序列放入正整数序列，凡是没有填入正整数序列的空格即所谓的确实的第一个最小正整数


错误点： 参看代码
1和2 是具体的这个case的出错点

3则是在使用当前数组内部挪移节点新概念后， 遇到的一个新的问题，
就是如果节点值已经被改变，那么这个节点值不能再一次作为原来的索引去寻找原来对应的值了。（参看代码）

避免方法：交换节点，尽量缓存二次索引后的节点值，这样这个间接索引后的节点将会被优先赋值，一次索引的节点最后被改变。






55. Jump Game  <<<  divide and conquer / greedy

和41类似，使用的方法就是数组节点的值作为下个数组的索引来进行解题
和53类似，使用分而治之，或者叫做贪心也可以，利用数组的遍历，进行O(n)次的遍历，同时记下每一个节点当时最优的解，并与之前的最优解比较并进行暂存。

v2版本是自己一开始写的版本，可见代码的复杂度以及效率都不好。
在这个思路下，我写下了v3版本，但是与正确版本之间课件代码更复杂。




49. Group Anagrams
对数组，字符串，字符的各种转换操作需要加强熟练度
String => byte array
       => char array => String

对Map的使用不够熟练
Map.values()  返回List， 元素类型即为Map的value的类型

这道题的提示就在于对于给出的字符串求某种相等的匹配，不需要考虑字符串中字符的顺序，应该想到的是排序。





66. Plus One
与42题目中所写的最后一个注意点类似，当2个变量交织在代码中使用时，即2个都需要改变，但是2个值都同时基于2个的原值来计算，则最好使用临时变量
int tmp = digits[i];
digits[i] = (tmp + extraOne)%10;
extraOne = (tmp + extraOne)/10;

41题目中的：
int tmp = nums[nums[index] - 1];
nums[nums[index] - 1] = nums[index];
nums[index] = tmp;



75. Sort Colors

原来的设计是i的递进放在for循环里，所以当nums[i] == 1时候，默认就不需要处理了
但是后来改了设计，为了方便处理nums[i] == 2时候的操作，把i++拿出来
结果忘记了处理 nums[i] ==1时候的i的递进。所以出错了，教训：

1. 改设计逻辑的时候，哪怕是最小的设计逻辑，请重新review所有原来的思路是否有需要改变的地方
2. 题目写完，思考更多的符合条件的边缘testcase ！！！！！！！！！！！！！！



121. Best Time to Buy and Sell Stock
低级错误，比较获取lowestBuy时，取最小值，但是初始化值我用了0，导致所有的price都比这个小，结果当然是错的

如果某值是用来比较并获取min，那么可以初始化为 Integer.MAX_VALUE
反之，如果是比较并获取max，那么可以初始化为 Integer.MIN_VALUE


128. Longest Consecutive Sequence

这个题目如果是不重复的 non-negative interger作为元素的话，则时间复杂度O(n), 空间复杂度O(1)，即可实现
在数组内部做原地腾挪，类似于41题，那样按照数组索引的排序将数据进行排序

但是如果1. 数据可能出现重复， 或者： 2. 数据为Integer,即可正可负的话，则不得不引入额外的空间复杂度。
用HashSet缓存数据，这样无论是 contains、remove操作都会在（1）的操作范围内。



53. Maximum Subarray   <<< DP / Greedy
Kadane算法
动态规划，当之前的sum加上当前值，比当前值还小，则放弃之前的sum，从本次继续开始计数
遍历过程中，在对每个节点计数时，sum需要保存到全局值中以取得过程当中的最优解


152. Maximum Product Subarray
解题思路就是不仅需要存储每个当前节点能算到的最大值，同时也要存储当前节点能得到的最小值，因为最小值可能在后来变成最大值

   所以和 53 题区别就是，我们需要在每个当前节点记录下2个条件：
   a. max： 要么是max/min和当前节点的乘积，要么是当前节点自己本身，取大的
   b. min： 要么是min/max和当前节点的乘积，要么是当前节点自己本身，取小的

   53只需要记录下当前最大的sum值
   其他思想和 53 题类似，一次遍历数组，存下当前每一个点能计算出的最优值，供后续使用比较，同时存下全局的最大值作为最终的输出



198. House Robber
动态规划：  f(n) = Max(f(n-1), f(n-2) + nums[i])
第n个打劫最优解，要么是之前一个已经背打劫，放弃本次打劫， 要么是前面没有打劫，本次打劫最优就是前前次打劫的基础上加上本次的。
遍历结束后，最后一个房子的最优解即是最终解


这个和53，152有小小区别，结束后的值是最优解，之前2个题目都是遍历过程中，保存最优解
那么什么时候采用和53、152类似的操作，每次遍历保存结果？？？？？？？？？？？？？？？？？？？？？？？？？？？？
当遍历过程中存在减分项，即后续访问的节点导致最优解不再是最优解的时候，需要实时记录每次的最优解。
53， 152， 还有之前计算tree中的最大sum的子树，都是这样的情况。

这个题目，保证值都是non-integer，即不存在拖后腿的节点，每次都是往上增加，故不需要保存中间解，只需要拿最后一个。
198、213，337都是这个情况， 尤其337的解题思路和计算tree中最大sum的子树是一样的，唯一的区别就是没有保存中间结果。
因为这里没有拖后腿的节点，故不需要比较并保存当前值


213. House Robber II
337. House Robber III

213. House Robber II
最后一个房子是否打劫依赖于第一个房子是否被打劫，那么干脆做2次，1次假定第一个房子被打劫，1次假定第一个房子不被打劫

类似于分糖中的贪心算法，干脆拆成2次，每一次都完成最优解

拆成2次，每次在不同情况下做最优解，比较适合应用在这种需要应付可能出现两种不同条件下的求解。




628. Maximum Product of Three Numbers

纯粹的数学推导理论：  排序后的结果 O(nLogn)，或者直接遍历一遍的结果 O(n)

思路： 最优解： 三个最大的数字相乘， 也有可能是两个最小的负数相乘，然后乘上最大的正数    <===================== 数学规律能找到？？？？？
解题： 遍历数组，判断各种情况？ 三个正数？三个负数？有正有负？2个负数的时候，只有1个正数的时候，有2个正数的时候？

      以上太复杂，策略上的DP， 将可能出最优解的两种情况分开计算，最终比较两者的最优解，得出最优解！！！！！！！！！！！！！！！！！！！！！


162. Find Peak Element

1. 如果中间节点不是peak，那么peak必在两边偏高的那一边   <============  数学规律能找到 ？？？？？？？？
2. 这个题目正常写法有点啰嗦，但是简化写法很tricky
     a.  循环里不存在=，因为=的时候就是我们找到目标
     b.  比较的时候只和+1做比较，因为肯定不会向上溢出，不会向上溢出的原因就是循环中的=不存在
     c.  为了防止向下溢出，right=mid，而不是mid-1


二分查找注意点： left + (right - left)/2, 而不是(left + right)/2，后者可能溢出
   递归版本： left = mid + 1 / right = mid - 1， 作为参数继续传入
   循环版本： while(left <= right)   ，左右边界可以重合



169. Majority Element

Hash:                       time: O(n),     space: O(n)
Sort:                       time: O(nlogN), space: O(1)
Moore voting algorithm :    time: O(n),     space: O(1)

由于题目中说明了，肯定有众数的存在，所以不需要验证众数的步骤


229. Majority Element II
Moore voting algorithm，并且需要验证众数是否有效





189. Rotate Array

考点： 数组内部的挪移

出错点：
方法1中，对于数组的挪移，是区分不同的数据段的，数据段的数量取决于数组长度和挪移步进的公约数求公约数的函数属于应用数学，需要记住

方法2中，不能简单的认为挪移的步进会小于数组的长度，应该和方法1中一样，把步进队数组长度进行取模操作，得到真正需要挪移的步进！！！！！！！！！不能忘记做输入参数的完整性检测！！！！！！！



238. Product of Array Except Self
第一想法是遍历一次无法得到结果，因为只能计算前面部分，所以想到了先遍历一次得到总乘积，然后再遍历第二次计算得到每个节点的值

那么为什么在第一时间既然想到了遍历一次不够，为什么没有想到策略DB，左边来一次，右边来一次呢？？？？？？这个思维为什么还没有建立起来？？？？？





268. Missing Number

解题思路1： 数组内部按照值和索引进行挪移
坑： 1. 索引前进的条件，值大于数组长度，值为负（此题目没有这个限制）， 值和索引一致
    2. 索引交换条件， 过了上述条件之后的else if分支条件： 值和所以不一致，且目标索引值和此处值不重复（此题没有这个限制）
    3. 如果2中的值有重复的话需要步进，此题没有该限制，第二分支直接可以用else而不是else if
    4. 最后扫描排序的数据找到missing的数据，但是如果都是按照序列排列的，那么需要返回最后一个值的+1，表示缺了最后一个
       所以一定要了解题意！！！！！！！！！！！！！
       即使你自己认为自己了解题意了，也要针对边缘情况，极限case来询问最后的结果是什么！！！从而真正了解题意！！！！！！！！！
       ！！！！！！！！！！！！！！！！！！！


解题思路2： 既然我们知道要把数值n和索引n对应起来找到缺失的那一个，我们可以把题目转换为 0-n数字成对出现，但是确实了一个数字，找出来
          利用数字两两异或，如果成对出现异或结果为0，如果缺失1个，那么异或的结果就是缺失的数字
坑： 需要考虑n个数字，可能出现n，遍历只能遍历到索引n-1，所以还需要额外异或一次n，那么我们就能得到缺失的结果是 0 - n中的具体哪一个。
    n就是解题思路1中需要考虑的第4项


解题思路3： 排序，再遍历一次找到missing number




287. Find the Duplicate Number

数组索引以及索引对应的值之间穿起来的关系，有一个相关的题目，不同的是这次不能讲节点根据索引和值之间的关系进行挪移

而是直接根据索引和值的关系串成一个单链表，转换成寻找有环单链表的环入口节点




289. Game of Life

1. 对于如何减少数据的读取次数， v3， 减少了内存的读取次数，每次访问一个邻居节点，只需要计算3个节点
   但是需要额外的存储空间

2. In-Place如何实现少读取？ v2 对每个节点遍历时，使用Min，Max来比较目标值和边界值，可以省去一些多余的内存读操作
   同时对于节点的中间状态存储，由于只存在0和1，那么我们可以用第二个bit来作为最终值的存储，默认都为0，只有最终为1的，
   我们设置其值，最后遍历一次，讲所有值右移1位

错误点：
1. V3中对中间值为16进行比较时，误写成： n & 16 == 1，低级错误，应该是 n & 16 == 16或者 n & 16 > 0

2. v2中对于getNeighbours函数，其中的循环错了2个地方，太大意了！！！！！！！！！ 请把每一次做题当做真正的做题，而不是测试！！！！！！！！！！！！！！！！！！！
    a. i和j的起始值就错了，应该选择 i-1和0之间的max，而不是min
    b. i和j的终止值也错了，应该是小于等于， 求max：i+1或者board.length - 1


扩展1：
假如矩阵是一个循环矩阵，怎么处理，例如3*3的矩阵，a[0][0]的左边是a[0][2], 上边是a[2][0]
    v2， 那么对于每一个节点，访问邻居节点的for循环应该如下:
        1. 横坐标纵坐标需要加上数组的长度!!!!!!!!!!!!!!!!!!!!!!!!!!
        2. 坐标实际使用时需要取模!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        此方法很适合做循环数组时用到！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
int m = board.length;
int n = board[0].length;
for(int i = i - 1 + m; i < i + 1 + m; i++) {
    for(int j = j - 1 + n; j < j + 1 + n; j++) {
        int counter = 0;
        if((board[i%m][j%n] & 1) == 1)
          counter++;
    }
}

扩展2：
如果矩阵很大，该如何操作，可以在v2的基础上，结合v1中保存哪些结点需要改变状态，这样无需第二次遍历整个矩阵，而只是更新相应的点即可。

扩展3：
多核机器上的优化，在扩展2的基础上，将矩阵进行切割，例如切成4块，每个线程处理子块，主线程处理4个字块边缘部分的节点，最终生成一个
需要修改状态的节点的list，用这个list生成新的矩阵

扩展4：
多机上的优化，讲扩展3的多线程改成分割矩阵后分发到不同的机器分别计算，然后再将每个机器上生成的哪些几点需要改变的list收集起来到主机，
同时主机也要处理边缘节点的计算





48. Rotate Image

90度旋转，显示沿着对角线对折矩阵，交换数据，然后：
    如果是clockwise，则进行左右交换
    如果是anticlockwise，则进行上下交换

如果180度交换，则上下交换+左右交换



54. Spiral Matrix

Matrix的各种遍历问题，此处用的可以说是某种贪心算法，处理一部分数据后更新各项坐标，缩小处理问题的范围



138. Copy List with Random Pointer
由于random所指向的对象未知，所以必然要遍历链表2次，然后接下的问题就是如何将原始链表中的节点
和新生成的节点之间做映射关系呢？？？不知道映射关系，无法在新链表中设置random指针：
1. 想到的第一个方案就是，采用一个HashMap保存老节点和新节点之间的映射关系
2. 上述方案需要使用extra space， 新方案就是新生成的节点放在原始链表中，紧跟在原始节点之后
   在链表中以步进为2进行遍历，即遍历原始链表；
   遍历第一次，生成所有节点，并放置于原始列表中紧跟原始节点
   遍历第二次，设置相关的random节点
   遍历第三次，恢复原始链表，讲新链表挪出来。

   曾经尝试将第三次遍历省略掉，放在第二次遍历中操作，但是不行，因为random指向的节点未知，有可能
   是前向节点，也有可能是后向节点。
   如果仅仅是前向节点，则可以省略第三次遍历，每次设置random的时候，同时将新老链表设置
   由于存在random可能指向后向的某个节点，所以无法再第二次遍历的时候，设置新老链表。



148. Sort List
考点：
    1. merge sort 的解题思路
    2. 寻找 single-linked list的中间节点
    3. merge two sorted list




190. Reverse Bits

arithmetic shift = signed shift : >>  如果是负数，则补1
logical shift = unsigned shift: >>>   如果是负数，则补0

另一种求解方式带来的思考：
如果想避免正负数的坑，请
尽量使用左移操作。




137. Single Number II
先画一个真值图：
Twos    Ones    Input   new_Twos    new_Ones
0       0       0       0           0
0       1       0       0           1
1       0       0       1           0
0       0       1       0           1
0       1       1       1           0
1       0       1       0           0

假定 Twos => A, Ones => B, Input = C

new_Ones's logic representation (逻辑表达式)
        A'BC' + A'B'C = A'(BC'+B'C) = A'(B⊕C) = (B ^ C) & (~A)

new_Twos' logic representation （逻辑表达式）
        AB'C' + A'BC

根据上述推导得到代码如下：
int tmp = (ones ^ input) & (~twos)
twos = (twos & (~ones) & (~input)) +  ((~twos) & B & C)
ones = tmp;

缺点： 1. twos的表达式太复杂。  2. ones没法直接设置，需要引用临时变量，以为twos是依赖最原始的ones值的
改进： 将新生成的ones作为输入，替换原有的ones，即ones的输出作为twos的输入
      那么twos的逻辑表达式如下：
      new_Twos = AB'C' + A'B'C = B'(AC'+A'C) = B'(A⊕C) = (A ^ C) & (~B)
根据新的逻辑，twos依赖新生成的ones，改进代码如下：
ones = (ones ^ input) & (~twos)
twos = (twos ^ input) & (~ones)

小总结：根据卡诺图推导如下：
    AB              =>  A & B
    A'              =>  ~A
    AB' + A'B = A⊕B => A ^ B
    A⊕B + AB        => A | B




3. Longest Substring Without Repeating Characters

String 和 char 的转换操作不熟练.
String.charAt()等等

题目的算法思想不复杂，很容易想到，但是算法的实现上很考验能力
初次想到的代码：
    在发现有重复项之后，else分支中实现一个新的while循环来删除
    set中重复项之前的所有字母，然后设置flag，
    到if分支中查看set不存在，并且flag设置了，认为这是一个新的
    substring的开始，然后开始计数

代码的实现非常的low，非常的啰嗦，不如当前实现的简洁易懂。

只使用1个循环，主循环测算是否到达字符串的尾，只有在if分支中移动计数器，
当if分支不为真时，缓存字符并且移动计数器，实现达到字符串的尾部。
else分支中用来删除set中的项，计数器用来记录当前删除的位置，当重复项删除之后，
if分支再一次为真。




12. Integer to Roman
初始的思路比较啰嗦，将int转化为string，然后遍历string中的元素，
并在此将元素转化为int来进行判断，根据int的不同值来判定如何生成罗马字符串

不好：
    1. 代码比较啰嗦，效率不高
    2. 对于字典表格，应该采用string，而不是char，因为char在字符串拼接方面不好，
       sb.apend貌似将char当做数字值得来处理
    3. 同2类似，当遍历字符串时，去除一个char，将该char转为一个int，结果转为的是
       该char的ASCII值而不是对应的数字值，从而不得不使用一个特殊的函数Character.getNumericValue()

综上所述，对该类型题改为如下：
对int值得拆分，分别处理个十百千位的每一位，得到相应字符串，最后拼接成目标字符串。

同时注意： string的拼接使用StringBuilder的性能比字符串直接相加要快。



14. Longest Common Prefix

学习使用string的各种方法，例如： indexOf(), substring()

注意method的大小写，以及多关注method内部的实现



20. Valid Parentheses
v2: 学习使用string的方法， 例如： toCharArray(), containsKey()

v1: 效率更高，减少了额外的存储。
    减少额外存储的思想类似于2sum一样，根据一个定位另一个，那么干脆在定位源的时候
    就将目标值缓存，那么后续目标值出现时，即可比较，而无需v2中那样建立映射关系
    该方法适用于二元定位查找



28. Implement strStr()

参考了Java的indexOf的源代码



8. String to Integer (atoi)
题目简单，或者题目会做，做过的话一定冷静，思考各种坑，以及边缘case。
代码出错：
    1. 判断条件使用了  if(char > '0' && char < '9'), 应该是闭合区间，而我写的是开区间
    2. 当时得到数字字符串后，没有判断特殊情况，数字以0为开始的话，需要调整一下
    3. 判断得到的数字是否超出Integer.MAX_VALUE/MIN_VALUE，我只是简单判断每一个位置上的数字
       是否大于目标值，但其实比较高位符合条件，比上下限小的时候即可返回真；然后在判断是否大于上下
       限，大于再返回假；
    4. int的上下临界  [-2^31, 2^31), 是个左闭合区间，我们得到一个合法字符串后，我采用的方法
       是先转换成int，然后判断符号，如果是负数，返回前加上负号。这是错的！！！！
       左边临界值无法先通过上述方法得到，将2^31的字符串转换成数值时将会报错溢出，
       应该直接将字符串组成完整形式，负号+数字，然后将该字符串转换成数值



17. Letter Combinations of a Phone Number

函数递归？  遍历所有元素单独处理？
采用的是递归+遍历的结合，遍历所有元素，随着index不同，对所有元素使用同一个函数处理，每一次输出的结果作为下次的输入



224. Basic Calculator
错误点：
    1. 边缘case没有考虑多位数的参与，根据字面的提示只思考了个位数
    2. 边缘case没有考虑只有数字，没有其他符号的出现， 题目中用词："may contain ()+-"，所以是可能不存在的
    3. 边缘case没有考虑字符串中可能出现的 white space，这些white space在字符串转换成数字的时候，需要摒弃掉
    4. 边缘case参考2，还有一种可能就是最后出现的字符串为数字



132 Pattern

S1  小
S2  大
S3  中

正向找，可以找到S1, S2, 然后当处理S3的时候，发现新来的数据比S2小，但是也比S1小，那么就没法处理
逆向找，可以看到S1和S3是邻接关系，找一个最大的S2，最大的S3，
维护这一对数组中能找到的最大，第二大的数据，只需要比较新来的数据
假如比最大的还要大，那么替换最大的，最大的pop出栈，替换第二大的
假如比最大的小，但是比第二大的要大，那么继续入栈
假如比最大的小，比第二大的也小，那么可以返回true

可以见我们需要转为这道题目为顺序查找数据一个比一个大的序列



295. Find Median from Data Stream
出错点
1. 5/2 返回2.0，  5/2.0返回2.5
2. PriorityQueue当元素为Integer的时候，默认为升序，即：MinHeap， 如果需要MaxHeap，获得降序列，
   则需要自定义Comparator，其中compare函数的两个形参应该为 public int compare(Integer o1, Integer o2)
   而不是int。
3. 比较的函数最好使用compareTo




480. Sliding Window Median

sliding window，减少一个元素，增加一个元素
1. 使用heap，但是不能使用PriorityQueue，因为需要挪出元素
2. 使用TreeSet,但是不能放入重复元素，所以需要引入一个类，额外引入id的概念，val相同则对id进行操作
3. TreeSet默认就是升序列，可以定义Comparator对类进行比较，放入到TreeSet的定义中
   也可以在类的定义中直接实现compareTo函数
   同时定义 class Node implements Comparable<Node> {...}
4. 加节点，减节点时需要先操作节点的插入/移除操作，然后在进行节点总数的计数

5. 求中位数时，当为偶数，为中间两点相加除以2的平均数为double
   两位数相加需要注意溢出的情况，
   故不采用 （a+b）/2.0
   而采用： a/2.0 + b/2.0

6. 同样是溢出问题，在比较器中，定义如下
   if(this.val == other.value)
        return this.id - other.id;
   else
        return this.val - other.val;

   两个实数相加需要防止溢出，同理两个实数相减也要防止溢出，
   例如： int a = 2^31 - 1;
         int b = -a;
         return a - b;
   需要修改比较器代码


对于这种int的相关加减操作，一定要注意代码的写法，防止溢出。
或者干脆，对于参数中独处的int数或者数组，在自己的数据结构中作为long来存储，
这样后续的加减操作也不用担心溢出的问题了。




